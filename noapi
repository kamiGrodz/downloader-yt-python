#!/usr/bin/env python3
"""
YouTube Video Downloader Script (No API Version)
Fetches latest videos from YouTube channels and downloads them
"""

import json
import os
import re
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional

try:
    import yt_dlp
except ImportError:
    print("yt-dlp is required. Install it with: pip install yt-dlp")
    sys.exit(1)


class YouTubeDownloader:
    def __init__(self):
        self.config_file = "config.json"
        self.videos_file = "fetched_videos.json"
        self.config = self.load_config()

    def load_config(self) -> Dict:
        """Load configuration from file or create default"""
        default_config = {
            "channels": [
                "@TechLinked",
                "@stopcs",
                "@LinusTechTips",
                "@penguinz0",
                "@Seytonic"
            ],
            "download_path": "./downloads",
            "default_days": 3,
            "video_quality": "best",
            "audio_quality": "best",
            "format": "mkv",
            "audio_only": False,
            "subtitle_languages": ["en"],
            "download_subtitles": False
        }

        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                # Merge with defaults to ensure all keys exist
                for key, value in default_config.items():
                    if key not in loaded_config:
                        loaded_config[key] = value
                return loaded_config
            except (json.JSONDecodeError, IOError) as e:
                print(f"Error loading config: {e}")
                print("Using default configuration")

        # Save default config
        self.save_config(default_config)
        return default_config

    def save_config(self, config: Dict = None) -> None:
        """Save configuration to file"""
        config = config or self.config
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=4, ensure_ascii=False)
        except IOError as e:
            print(f"Error saving config: {e}")

    def get_yt_dlp_opts(self, audio_only: bool = False, custom_quality: str = None) -> Dict:
        """Get yt-dlp options based on configuration"""
        download_path = Path(self.config["download_path"])
        download_path.mkdir(exist_ok=True)

        if audio_only:
            opts = {
                'format': 'bestaudio/best',
                'outtmpl': str(download_path / '%(uploader)s/%(title)s.%(ext)s'),
                'extractaudio': True,
                'audioformat': 'aac',
                'audioquality': '320K',
            }
        else:
            format_selector = custom_quality or self.config["video_quality"]
            if format_selector == "best":
                format_str = f'best[ext={self.config["format"]}]/best'
            else:
                format_str = format_selector

            opts = {
                'format': format_str,
                'outtmpl': str(download_path / '%(uploader)s/%(title)s.%(ext)s'),
                'merge_output_format': self.config["format"],
            }

        if self.config.get("download_subtitles", True):
            opts.update({
                'writesubtitles': True,
                'writeautomaticsub': True,
                'subtitleslangs': self.config.get("subtitle_languages", ["en"]),
            })

        opts.update({
            'ignoreerrors': True,
            'no_warnings': False,
            'extractflat': False,
        })

        return opts

    def fetch_channel_videos(self, days: int = None) -> List[Dict]:
        """Fetch latest videos from configured channels"""
        days = days or self.config["default_days"]
        cutoff_date = datetime.now() - timedelta(days=days)
        all_videos = []

        print(f"Fetching videos from the last {days} days...")

        for channel in self.config["channels"]:
            print(f"Processing channel: {channel}")
            try:
                # Get channel videos
                ydl_opts = {
                    'quiet': True,
                    'extract_flat': True,
                    'playlistend': 5,  # Get recent videos
                }

                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    # Try different channel URL formats
                    channel_urls = [
                        f"https://www.youtube.com/{channel}/videos",
                        f"https://www.youtube.com/c/{channel.lstrip('@')}/videos",
                        f"https://www.youtube.com/user/{channel.lstrip('@')}/videos",
                    ]

                    channel_info = None
                    for url in channel_urls:
                        try:
                            channel_info = ydl.extract_info(url, download=False)
                            break
                        except:
                            continue

                    if not channel_info:
                        print(f"Could not fetch videos from {channel}")
                        continue

                    # Filter videos by date
                    for entry in channel_info.get('entries', []):
                        try:
                            # Get detailed info for date filtering
                            video_info = ydl.extract_info(
                                f"https://www.youtube.com/watch?v={entry['id']}",
                                download=False
                            )

                            upload_date = video_info.get('upload_date')
                            if upload_date:
                                video_date = datetime.strptime(upload_date, '%Y%m%d')
                                if video_date >= cutoff_date:
                                    video_data = {
                                        'id': entry['id'],
                                        'title': video_info.get('title', 'Unknown'),
                                        'uploader': video_info.get('uploader', 'Unknown'),
                                        'upload_date': upload_date,
                                        'url': f"https://www.youtube.com/watch?v={entry['id']}",
                                        'duration': video_info.get('duration', 0),
                                        'view_count': video_info.get('view_count', 0)
                                    }
                                    all_videos.append(video_data)
                        except Exception as e:
                            print(f"Error processing video {entry.get('id', 'unknown')}: {e}")
                            continue

            except Exception as e:
                print(f"Error fetching from channel {channel}: {e}")
                continue

        # Sort by upload date (newest first)
        all_videos.sort(key=lambda x: x['upload_date'], reverse=True)

        # Save to JSON file
        try:
            with open(self.videos_file, 'w', encoding='utf-8') as f:
                json.dump(all_videos, f, indent=4, ensure_ascii=False)
            print(f"Saved {len(all_videos)} videos to {self.videos_file}")
        except IOError as e:
            print(f"Error saving videos: {e}")

        return all_videos

    def download_from_json(self) -> None:
        """Download videos from the fetched JSON file"""
        if not os.path.exists(self.videos_file):
            print(f"No video file found. Please fetch videos first.")
            return

        try:
            with open(self.videos_file, 'r', encoding='utf-8') as f:
                videos = json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Error reading video file: {e}")
            return

        if not videos:
            print("No videos found in the file.")
            return

        print(f"Found {len(videos)} videos to download.")

        # Show videos and let user select
        print("\nAvailable videos:")
        for i, video in enumerate(videos, 1):
            print(f"{i:2d}. {video['uploader']} - {video['title']} ({video['upload_date']})")

        choice = input(
            f"\nEnter video numbers to download (1-{len(videos)}, 'all' for all, or ranges like '1-5'): ").strip()

        if choice.lower() == 'all':
            selected_videos = videos
        else:
            selected_videos = self._parse_selection(choice, videos)

        if not selected_videos:
            print("No videos selected.")
            return

        print(f"Downloading {len(selected_videos)} videos...")

        ydl_opts = self.get_yt_dlp_opts(audio_only=self.config["audio_only"])

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            for video in selected_videos:
                try:
                    print(f"Downloading: {video['title']}")
                    ydl.download([video['url']])
                except Exception as e:
                    print(f"Error downloading {video['title']}: {e}")

    def download_from_file(self, file_path: str) -> None:
        """Download videos from a file containing YouTube links"""
        if not os.path.exists(file_path):
            print(f"File {file_path} not found.")
            return

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except IOError as e:
            print(f"Error reading file: {e}")
            return

        # Extract YouTube URLs using regex
        youtube_regex = r'https?://(?:www\.)?(?:youtube\.com/watch\?v=|youtu\.be/)([a-zA-Z0-9_-]{11})'
        urls = re.findall(youtube_regex, content)

        if not urls:
            print("No YouTube URLs found in the file.")
            return

        # Convert to full URLs
        full_urls = [f"https://www.youtube.com/watch?v={video_id}" for video_id in urls]

        print(f"Found {len(full_urls)} YouTube URLs.")

        ydl_opts = self.get_yt_dlp_opts(audio_only=self.config["audio_only"])

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            for url in full_urls:
                try:
                    print(f"Downloading: {url}")
                    ydl.download([url])
                except Exception as e:
                    print(f"Error downloading {url}: {e}")

    def download_single_video(self, url: str, custom_options: Dict = None) -> None:
        """Download a single video with custom options"""
        if not url:
            print("No URL provided.")
            return

        # Validate YouTube URL
        if not re.match(r'https?://(?:www\.)?(?:youtube\.com/watch\?v=|youtu\.be/)', url):
            print("Invalid YouTube URL.")
            return

        audio_only = False
        custom_quality = None

        if custom_options:
            audio_only = custom_options.get('audio_only', False)
            custom_quality = custom_options.get('quality')

        ydl_opts = self.get_yt_dlp_opts(audio_only=audio_only, custom_quality=custom_quality)

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                print(f"Downloading: {url}")
                ydl.download([url])
                print("Download completed successfully!")
            except Exception as e:
                print(f"Error downloading video: {e}")

    def _parse_selection(self, selection: str, items: List) -> List:
        """Parse user selection string and return selected items"""
        selected = []
        parts = selection.split(',')

        for part in parts:
            part = part.strip()
            if '-' in part:
                try:
                    start, end = map(int, part.split('-'))
                    for i in range(start - 1, min(end, len(items))):
                        if i >= 0:
                            selected.append(items[i])
                except ValueError:
                    continue
            else:
                try:
                    idx = int(part) - 1
                    if 0 <= idx < len(items):
                        selected.append(items[idx])
                except ValueError:
                    continue

        return selected

    def configure_settings(self) -> None:
        """Interactive configuration menu"""
        while True:
            print("\n" + "=" * 40)
            print("CONFIGURATION MENU")
            print("=" * 40)
            print(f"1. Channels: {', '.join(self.config['channels'])}")
            print(f"2. Download path: {self.config['download_path']}")
            print(f"3. Default days: {self.config['default_days']}")
            print(f"4. Video quality: {self.config['video_quality']}")
            print(f"5. Audio quality: {self.config['audio_quality']}")
            print(f"6. Format: {self.config['format']}")
            print(f"7. Audio only: {self.config['audio_only']}")
            print(f"8. Download subtitles: {self.config['download_subtitles']}")
            print(f"9. Subtitle languages: {', '.join(self.config['subtitle_languages'])}")
            print("0. Back to main menu")

            choice = input("\nSelect option to modify: ").strip()

            if choice == '0':
                break
            elif choice == '1':
                self._configure_channels()
            elif choice == '2':
                new_path = input(f"Enter new download path (current: {self.config['download_path']}): ").strip()
                if new_path:
                    self.config['download_path'] = new_path
            elif choice == '3':
                try:
                    days = int(input(f"Enter default days (current: {self.config['default_days']}): ").strip())
                    self.config['default_days'] = days
                except ValueError:
                    print("Invalid number.")
            elif choice == '4':
                print("Video quality options: best, worst, best[height<=720], etc.")
                quality = input(f"Enter video quality (current: {self.config['video_quality']}): ").strip()
                if quality:
                    self.config['video_quality'] = quality
            elif choice == '5':
                quality = input(f"Enter audio quality (current: {self.config['audio_quality']}): ").strip()
                if quality:
                    self.config['audio_quality'] = quality
            elif choice == '6':
                format_ext = input(f"Enter format (current: {self.config['format']}): ").strip()
                if format_ext:
                    self.config['format'] = format_ext
            elif choice == '7':
                audio_only = input(
                    f"Audio only? (y/n, current: {'y' if self.config['audio_only'] else 'n'}): ").strip().lower()
                if audio_only in ['y', 'n']:
                    self.config['audio_only'] = audio_only == 'y'
            elif choice == '8':
                subtitles = input(
                    f"Download subtitles? (y/n, current: {'y' if self.config['download_subtitles'] else 'n'}): ").strip().lower()
                if subtitles in ['y', 'n']:
                    self.config['download_subtitles'] = subtitles == 'y'
            elif choice == '9':
                langs = input(
                    f"Enter subtitle languages (comma-separated, current: {', '.join(self.config['subtitle_languages'])}): ").strip()
                if langs:
                    self.config['subtitle_languages'] = [lang.strip() for lang in langs.split(',')]

            # Save configuration after any change
            self.save_config()
            print("Configuration saved!")

    def _configure_channels(self) -> None:
        """Configure YouTube channels"""
        while True:
            print(f"\nCurrent channels:")
            for i, channel in enumerate(self.config['channels'], 1):
                print(f"{i}. {channel}")

            print("\n1. Add channel")
            print("2. Remove channel")
            print("3. Back")

            choice = input("Select option: ").strip()

            if choice == '1':
                channel = input("Enter channel name (e.g., @mkbhd): ").strip()
                if channel and channel not in self.config['channels']:
                    self.config['channels'].append(channel)
                    print(f"Added {channel}")
            elif choice == '2':
                try:
                    idx = int(input("Enter channel number to remove: ").strip()) - 1
                    if 0 <= idx < len(self.config['channels']):
                        removed = self.config['channels'].pop(idx)
                        print(f"Removed {removed}")
                except (ValueError, IndexError):
                    print("Invalid selection.")
            elif choice == '3':
                break

    def run(self) -> None:
        """Main menu loop"""
        while True:
            print("\n" + "=" * 40)
            print("YOUTUBE DOWNLOADER (No API Version)")
            print("=" * 40)
            print("1. Fetch latest videos from channels")
            print("2. Download videos from fetched")
            print("3. Download videos from a file with links")
            print("4. Download a single video (URL)")
            print("5. Configure settings")
            print("6. Exit")

            choice = input("\nSelect an option: ").strip()

            if choice == '1':
                days_input = input(f"Enter number of days (default: {self.config['default_days']}): ").strip()
                days = int(days_input) if days_input.isdigit() else self.config['default_days']
                self.fetch_channel_videos(days)

            elif choice == '2':
                self.download_from_json()

            elif choice == '3':
                file_path = input("Enter path to file with links: ").strip()
                self.download_from_file(file_path)

            elif choice == '4':
                url = input("Enter YouTube URL: ").strip()

                # Ask for custom options
                print("\nCustom download options:")
                audio_only = input("Download audio only? (y/n): ").strip().lower() == 'y'

                custom_quality = None
                if not audio_only:
                    quality = input("Enter video quality (press Enter for default): ").strip()
                    if quality:
                        custom_quality = quality

                custom_options = {
                    'audio_only': audio_only,
                    'quality': custom_quality
                }

                self.download_single_video(url, custom_options)

            elif choice == '5':
                self.configure_settings()

            elif choice == '6':
                print("Goodbye!")
                break

            else:
                print("Invalid option. Please try again.")


if __name__ == "__main__":
    try:
        downloader = YouTubeDownloader()
        downloader.run()
    except KeyboardInterrupt:
        print("\n\nProgram interrupted by user.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
